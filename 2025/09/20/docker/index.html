<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>docker | 王桑的个人博客</title><meta name="author" content="王桑"><meta name="copyright" content="王桑"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言：本篇笔记内容来自于 B 站 《40 分钟的 Docker 实战攻略，一期视频精通 Docker》视频，博主 @技术爬爬虾，视频地址：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1THKyzBER6。本笔记来源https:&#x2F;&#x2F;www.dbkuaizi.com&#x2F;archives&#x2F;465.html Docker 核心概念Docker 容器 Docker 简单来说就是通过容器化">
<meta property="og:type" content="article">
<meta property="og:title" content="docker">
<meta property="og:url" content="http://example.com/2025/09/20/docker/index.html">
<meta property="og:site_name" content="王桑的个人博客">
<meta property="og:description" content="前言：本篇笔记内容来自于 B 站 《40 分钟的 Docker 实战攻略，一期视频精通 Docker》视频，博主 @技术爬爬虾，视频地址：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1THKyzBER6。本笔记来源https:&#x2F;&#x2F;www.dbkuaizi.com&#x2F;archives&#x2F;465.html Docker 核心概念Docker 容器 Docker 简单来说就是通过容器化">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/docker.png">
<meta property="article:published_time" content="2025-09-20T12:18:50.000Z">
<meta property="article:modified_time" content="2025-09-24T12:43:59.627Z">
<meta property="article:author" content="王桑">
<meta property="article:tag" content="-docker笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/docker.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "docker",
  "url": "http://example.com/2025/09/20/docker/",
  "image": "http://example.com/img/docker.png",
  "datePublished": "2025-09-20T12:18:50.000Z",
  "dateModified": "2025-09-24T12:43:59.627Z",
  "author": [
    {
      "@type": "Person",
      "name": "王桑",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/09/20/docker/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'docker',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/back.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/wang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><span> 选项</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><span> Music</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/docker1.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">王桑的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">docker</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags"><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><span> 选项</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/"><span> Music</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">docker</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-20T12:18:50.000Z" title="发表于 2025-09-20 20:18:50">2025-09-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-24T12:43:59.627Z" title="更新于 2025-09-24 20:43:59">2025-09-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/docker/">-docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>前言：本篇笔记内容来自于 B 站 《40 分钟的 Docker 实战攻略，一期视频精通 Docker》视频，博主 <a target="_blank" rel="noopener" href="https://github.com/tech-shrimp/me">@技术爬爬虾</a>，视频地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1THKyzBER6%E3%80%82%E6%9C%AC%E7%AC%94%E8%AE%B0%E6%9D%A5%E6%BA%90https://www.dbkuaizi.com/archives/465.html">https://www.bilibili.com/video/BV1THKyzBER6。本笔记来源https://www.dbkuaizi.com/archives/465.html</a></p>
<h2 id="Docker-核心概念"><a href="#Docker-核心概念" class="headerlink" title="Docker 核心概念"></a>Docker 核心概念</h2><p><strong>Docker 容器</strong></p>
<p>Docker 简单来说就是通过容器化技术给应用程序封装一个独立的运行环境，每个运行环境就是一个容器，运行容器的计算机被称为 <strong>宿主机</strong>。</p>
<p>与虚拟机最大的区别是：<strong>Docker 容器共享同一个系统内核，而每个虚拟机都包含一个完整的系统内核。所以 Docker 容器比虚拟机更轻量，启动速度更快。</strong></p>
<p><strong>Docker 镜像</strong></p>
<p>镜像可以理解为是一个特殊的压缩包，容器就像是通过压缩包解压（创建）出来的文件，我们可以使用同一个压缩包，解压出很多份相同的文件，也可以将这个压缩包分享给他人，得到和我们一样的文件。这里所说的 “文件”，就是上面提到的容器。</p>
<p>我们也可以通过修改容器，并生成自己特定的 Docker 镜像，并将这些镜像分享给他人，其他人可以通过镜像，创建出和我们一样的容器环境。</p>
<p><strong>Docker 仓库</strong></p>
<p>Docker 仓库就是我们用来存储、分享镜像的地方。所有人都可以把自己的镜像上传到仓库里面，其他人就可以下载镜像并使用。</p>
<p>Docker 的官方仓库是 Docker Hub (<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a>)</p>
<h2 id="Docker-技术原理"><a href="#Docker-技术原理" class="headerlink" title="Docker 技术原理"></a>Docker 技术原理</h2><p>Docker 利用了 Linux 的两大原生功能，实现容器化：</p>
<ul>
<li><strong>Cgroups</strong> 用来限制和隔离进程的资源使用。可以为每个容器设定 CPU、内存、网络带宽等资源的使用上限，确保容器的内存消耗不会影响到宿主机。</li>
<li><strong>Namespaces</strong> 用于隔离进程的资源视图，使得容器只能看到自己内部的进程 ID、网络资源、文件目录，看不到宿主机的。</li>
</ul>
<p>容器本质上还是一个特殊的进程，但是当我们进入容器内部时，看起来就像是一个独立的操作系统</p>
<h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><p>Docker 是基于 Linux 的容器化技术，Windows 和 Mac 需要虚拟化一个 Linux 的子系统。所以 Docker 最好的使用方式是使用 Linux 系统的宿主机。</p>
<p><strong>Linux 系统</strong></p>
<p>Linux 系统可以通过包管理器安装 Docker，例如 Redhat 系可以使用 <code>yum install docker</code> 安装。</p>
<p>Alpine Linux 可以通过 <code>apk add docker</code> 安装</p>
<p><strong>Windows 安装</strong></p>
<p>打开 “Windows 功能”, 勾选上 Virtual Machine Paftform（虚拟机平台）、适用于 Linux 的 Windows 子系统，并重启电脑。</p>
<p>管理员打开命令提示符，安装 wsl2</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--set-default-version</span> <span class="number">2</span></span><br><span class="line">wsl <span class="literal">--update</span> <span class="literal">--web-download</span></span><br></pre></td></tr></table></figure>

<p>去 Docker 官网 或者 <a target="_blank" rel="noopener" href="https://github.com/tech-shrimp/docker_installer/releases">https://github.com/tech-shrimp/docker_installer/releases</a> 下载符合自己系统的 Docker Desktop 安装包，并进行安装，安装成功后 可以在终端尝试一下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\Administrator&gt; docker <span class="literal">--version</span></span><br><span class="line">Docker version <span class="number">28.3</span>.<span class="number">3</span>, build <span class="number">980</span>b856</span><br></pre></td></tr></table></figure>

<p>在使用的过程中 Docker Desktop 需要一直开着，否则执行命令会出现这个报错。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; docker ps</span><br><span class="line">error during connect: Get <span class="string">&quot;http://%2F%2F.%2Fpipe%2FdockerDesktopLinuxEngine/v1.51/containers/json&quot;</span>: open //./pipe/dockerDesktopLinuxEngine: The system cannot find the file specified.</span><br></pre></td></tr></table></figure>

<p><strong>Mac 安装</strong></p>
<p>直接在 Docker 官网下载安装包 安装就行。</p>
<h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>Docker Pull 命令用来从仓库下载镜像。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io/library/nginx:latest</span><br></pre></td></tr></table></figure>

<p>一个 Docker 镜像下载地址包含 4 部分内容：</p>
<ul>
<li><strong>docker.io:</strong> registry：仓库地址 &#x2F; 注册表，如果是 Docker 官方仓库，则可以省略这个地址。</li>
<li><strong>library:</strong> 命名空间（镜像作者），为了防止不同用户上传同一个名字的镜像 发生冲突。“library” 是 docker 官方仓库的命名空间，这个空间下的所有镜像都是由 Docker 官方维护。如果是官方的命名空间 则可以省略不写</li>
<li><strong>nginx:</strong> 镜像名</li>
<li><strong>latest:</strong> 标签名、版本号。写 “latest” 或者不写 表示获取最新版本的镜像。</li>
</ul>
<p><strong>镜像库</strong></p>
<p>repository: 镜像库，存放一个镜像的不同版本，”docker.io&#x2F;library&#x2F;nginx” 就是一个镜像库。</p>
<p>简化后的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 Docker 官方仓库的官方命名空间里面下载最新的 Nginx Docker 镜像</span></span><br><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<p>其他例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 docker.n8n.io 的私有仓库下载 n8nio 上传的 n8n 镜像</span></span><br><span class="line">docker pull docker.n8n.io/n8nio/n8n</span><br></pre></td></tr></table></figure>

<p><strong>Docker Hub</strong></p>
<p>docker 官方的镜像仓库地址为 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 可以在这个上面搜索自己需要的镜像，标有 “Docker Offcial Images” 表示 Docker 官方维护的镜像。</p>
<p>如果打不开 可以通过 <a target="_blank" rel="noopener" href="https://docker.fxxk.dedyn.io/">https://docker.fxxk.dedyn.io/</a> 镜像站来搜索镜像。</p>
<p><strong>镜像源配置</strong></p>
<p>在国内的网络环境中，如果执行 <code>docker pull</code> 可能会出现 下载失败的问题，可以参考这篇文档配置镜像站解决：<a target="_blank" rel="noopener" href="https://github.com/tech-shrimp/docker_installer?tab=readme-ov-file#2-pull%E9%95%9C%E5%83%8F">docker_installer?tab&#x3D;readme-ov-file#2-pull 镜像</a></p>
<p>（我尝试了 UP 的这几个镜像 下载还是失败了，最后用这个镜像可以正常下载，有需要的各位可以试试看）</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;https://docker.1ms.run&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>拉取特定架构的镜像</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull --platform=xxx nginx</span><br></pre></td></tr></table></figure>

<p>默认情况下，docker 会选择当前宿主机 CPU 架构的镜像，大部分情况下我们不需要关注这个参数。</p>
<p>Mac 目前的 M 系列 CPU 都是 arm 架构的，但在运行 AMD64 架构的容器时，会自动调用 QEMU 来模拟 x86_64 指令集，从而实现兼容 AMD64 的镜像，不过可能会存在一些兼容性问题 以及额外的性能开销。</p>
<h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>使用此命令可以查看 所有 Pull 到本地的镜像。</p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [镜像标识]</span><br></pre></td></tr></table></figure>

<p>使用此命令可以删除 pull 到本地的镜像，镜像标识可以选择 镜像的 ID（image id）或者镜像的名称（repository）</p>
<h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><h3 id="创建并运行容器"><a href="#创建并运行容器" class="headerlink" title="创建并运行容器"></a>创建并运行容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [镜像标识]</span><br></pre></td></tr></table></figure>

<p>使用 run 命令 可以通过 镜像创建一个容器，并启动它。镜像标识可以是 镜像 ID 或者镜像名称。</p>
<p>例如：<code>docker run nginx</code> 就是创建一个 Nginx 容器。</p>
<p>docker pull 命令可以省略，直接使用 docker run 运行，如果 docker 发现本地没有这个镜像 则会自动拉取。</p>
<p><strong>分离模式</strong></p>
<p>默认情况下 <code>docker run</code> 创建容器后会导致当前终端挂起，不能进行其他操作，可以增加 <code>-d</code> 参数 表示容器在后台运行，不阻塞当前窗口。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; docker run -d nginx</span><br><span class="line">c18e9f86c0c89f2d9984dbe566349542318f8e38bb86fd17579bd9f39a8c5977</span><br></pre></td></tr></table></figure>

<p><strong>自定义容器名称</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -name kz_nginx nginx</span><br></pre></td></tr></table></figure>

<p>容器的名称和 容器 ID 的效果是等价的，但是名字更方便记忆。</p>
<p><strong>端口映射</strong></p>
<p>容器的网络和宿主机的网络是隔离的，例如运行了一个 Nginx 容器，容器内的 Nginx 监听了 80 端口。这时通过宿主机的 80 端口是无法访问到 Nginx 服务的。</p>
<p>所以需要 <code>-p &#123;宿主机端口&#125;:&#123;容器端口&#125;</code> 命令进行映射，例如 <code>-p 8080:80</code> 标识将 Nginx 容器的 80 端口映射到宿主机的 8080 端口。</p>
<img src="/2025/09/20/docker/1.png" class="">

<p><strong>目录映射（绑定挂载）</strong></p>
<p>与端口映射类似的就是目录映射，将容器外和容器内的目录进行绑定，容器内对文件的修改会影响宿主机的文件夹，宿主机的修改也会影响容器内文件夹。这种目录也被称为 挂载卷，他的最大作用是数据的持久化。 当容器删除时，容器内的所有数据都会被删除，但通过挂载卷映射到宿主机的文件夹将得以保留。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 -v ./:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></figure>

<p>使用绑定挂载的时候，宿主机的文件会暂时覆盖掉容器内的目录。除了这种用法 还有一种叫 Docker 卷，可以在容器之间共享和重用。</p>
<p><strong>环境变量</strong></p>
<p>可以在命令行通过 <code>-e</code> 参数传递环境变量到容器内部，例如创建一个数据库应用，需要在 创建容器时，就指定数据库的账户、密码等信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 27017:27017 \</span><br><span class="line">-e MONGO_INITDB_ROOT_USERNAME=tech \</span><br><span class="line">-e MONGO_INITDB_ROOT_PASSWORD=dbkuaizi \</span><br><span class="line">mongo</span><br></pre></td></tr></table></figure>

<p>如果不知道容器的环境变量有哪些，可以在 Docker Hub 上搜索一下，或者去 Github 上看一下 readme 文档，都有详细的描述。</p>
<p><strong>进入容器</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it alpine</span><br></pre></td></tr></table></figure>

<p>通过 <code>-it</code> 参数可以在创建一共容器时，同时进入容器内部的终端。</p>
<p><strong>退出删除</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> alpine</span><br></pre></td></tr></table></figure>

<p><code>--rm</code> 表示当退出容器时，自动删除这个容器。一般和 <code>-it</code> 命令配合使用</p>
<p><strong>容器重启策略</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart always nginx</span><br></pre></td></tr></table></figure>

<p><code>--restart</code> 参数用来表示 容器在停止时的重启策略，它有两个选项：</p>
<ul>
<li><code>always</code> 只要容器停止了，就会立即重启。包含容器因为内部错误崩溃，或者宿主机断电等场景</li>
<li><code>unless-stopped</code> ，与 <code>always</code> 类似，唯一区别是：手动停止的容器不会尝试重启了</li>
</ul>
<h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create nginx</span><br></pre></td></tr></table></figure>

<p>与 run 命令功能类似，区别在于只创建容器，不自动启动。</p>
<h3 id="容器列表"><a href="#容器列表" class="headerlink" title="容器列表"></a>容器列表</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS     NAMES</span><br><span class="line">48fe482ecff2   nginx     <span class="string">&quot;/docker-entrypoint.…&quot;</span>   About a minute ago   Up About a minute   80/tcp    cool_hodgkin</span><br></pre></td></tr></table></figure>

<p>ps 是 Process Status (进程状态) 的缩写，也是 Linux 上的一个经典命令，用于查看进程的状态信息。这一命令也被继承到 Docker 里面了</p>
<p>这些列含义如下：</p>
<ul>
<li><code>CONTAINER ID</code> 容器 ID，每个容器在创建时会生成一个唯一的 ID</li>
<li><code>IMAGE</code> 基于那个镜像创建出来的</li>
<li><code>CREATED</code> 镜像创建时间</li>
<li><code>STATUS</code> 镜像当前状态</li>
<li><code>PORTS</code> 镜像使用端口</li>
<li><code>NAMES</code> 容器的名字，如果创建容器时没有指定名字，系统就会随机分配一个。</li>
</ul>
<p>增加 <code>-a</code> 参数可以看到所有的容器，包括正在运行的和已经停止的。</p>
<h3 id="启停容器"><a href="#启停容器" class="headerlink" title="启停容器"></a>启停容器</h3><p>每次使用 <code>docker run</code> 运行都会创建一个新的容器，如果我们需要对同一个容器进行持续的操作，可以通过 容器的启停命令来控制。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker start &#123;容器标识&#125;</span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop &#123;容器标识&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>start</code> 启停容器的时候，不需要再传递创建容器时的 端口映射、挂载卷、环境变量等参数都不需要重新写了，docker 已经自动保存了，重新启动可以按照原因运行。</p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> &#123;容器标识&#125;</span><br></pre></td></tr></table></figure>

<p>使用 rm 命令可以删除容器，如果要删除运行中的容器 需要加 <code>-f</code> 参数强制删除。</p>
<h3 id="容器内部"><a href="#容器内部" class="headerlink" title="容器内部"></a>容器内部</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &#123;容器标识&#125; bash</span><br></pre></td></tr></table></figure>

<p>使用 <code>exec -it</code> 命令 可以进入容器，在容器内部执行 shell 命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> &#123;容器标识&#125; &#123;shell 命令&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过这种方式 在容器外部执行容器内部的命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器 alpine 中的进程信息</span></span><br><span class="line">docker <span class="built_in">exec</span> alpine ps -ef</span><br></pre></td></tr></table></figure>

<p>注意 docker 镜像为了尽可能缩小镜像体积，内部一般是一个极简的操作系统，很多系统工具、基础命令都是缺失的</p>
<h3 id="查看创建信息"><a href="#查看创建信息" class="headerlink" title="查看创建信息"></a>查看创建信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &#123;容器标识&#125;</span><br></pre></td></tr></table></figure>

<p>使用这个命令可以看到容器的所有信息，输出的是一个 JSON 格式，可以直接丢给 ai 帮忙解析</p>
<h3 id="容器日志"><a href="#容器日志" class="headerlink" title="容器日志"></a>容器日志</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs &#123;容器标识&#125;</span><br></pre></td></tr></table></figure>

<p>这个命令可以看容器的日志，加上 <code>-f</code> 命令，可以持续输出，滚动查看。</p>
<h2 id="Docker-卷"><a href="#Docker-卷" class="headerlink" title="Docker 卷"></a>Docker 卷</h2><p>docker volume 命令用于管理 Docker 卷（volume）。卷是用于持久化数据的文件系统，可以将数据和应用程序分离，便于管理，可以在容器之间共享和重用。同时卷可以用于数据的备份和恢复。</p>
<h3 id="创建卷"><a href="#创建卷" class="headerlink" title="创建卷"></a>创建卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create &#123;卷名称&#125;</span><br></pre></td></tr></table></figure>



<h3 id="查看卷信息"><a href="#查看卷信息" class="headerlink" title="查看卷信息"></a>查看卷信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect nginx_html</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2025-09-07T14:58:39Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/nginx_html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;nginx_html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h3 id="查看所有卷"><a href="#查看所有卷" class="headerlink" title="查看所有卷"></a>查看所有卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker volume list</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     nginx_html</span><br></pre></td></tr></table></figure>



<h3 id="删除卷"><a href="#删除卷" class="headerlink" title="删除卷"></a>删除卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">rm</span> nginx_html</span><br></pre></td></tr></table></figure>



<h3 id="删除未使用的卷"><a href="#删除未使用的卷" class="headerlink" title="删除未使用的卷"></a>删除未使用的卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure>



<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile 是一个用来 构建镜像文件的文本文件，Dockerfile 文件内包含了构建镜像所需的各种信息。</p>
<p>在项目目录下创建一个名为 <code>Dockerfile</code> 的文件，并在文件中编写镜像构成的信息。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择一个基础镜像作为运行环境</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.13</span>-slim</span><br><span class="line"><span class="comment"># 在镜像内切换一个工作目录，后续所有的操作都是基于这个目录来的</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 将项目文件拷贝到镜像的工作目录</span></span><br><span class="line"><span class="comment"># 第一个 “.” 代表当前目录，第二个 “.” 代表镜像的工作目录 </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装容器内环境需要的依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明对外提供服务的端口是哪个</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器内服务启动命令，每次启动时容器内会自动执行这个命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python3&quot;</span>,<span class="string">&quot;main.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>项目内容</strong><br>main.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;hello&quot;</span>:<span class="string">&quot;dbkuaizi&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    uvicorn.run(app,host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<p>requirements.txt</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastapi</span><br><span class="line">uvicorn</span><br></pre></td></tr></table></figure>

<p><strong>构建镜像</strong></p>
<p>Dockerfile 文件写好了，可以使用 <code>docker build</code> 构建镜像。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PS E:\docker\demo&gt; docker build -t docker_test .</span><br><span class="line">[+] Building 65.7s (9/9) FINISHED                                                                                                                                                                                                                                  docker:desktop-linux</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                                                                                                                                                                                                               0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 616B                                                                                                                                                                                                                                               0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/python:3.13-slim                                                                                                                                                                                                                0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                                                                                                                                                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                                                                                                                                                                                                    0.0s</span><br><span class="line"> =&gt; [1/4] FROM docker.io/library/python:3.13-slim@sha256:1bca0202e953784ac2a1daf36ebbc9cbebed48afcfba12d1225aaab3793eca33                                                                                                                                                          0.0s</span><br><span class="line"> =&gt; =&gt; resolve docker.io/library/python:3.13-slim@sha256:1bca0202e953784ac2a1daf36ebbc9cbebed48afcfba12d1225aaab3793eca33                                                                                                                                                          0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                                                                                                                                                                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 310B                                                                                                                                                                                                                                                  0.0s</span><br><span class="line"> =&gt; CACHED [2/4] WORKDIR /app                                                                                                                                                                                                                                                      0.0s</span><br><span class="line"> =&gt; [3/4] COPY . .                                                                                                                                                                                                                                                                 0.1s</span><br><span class="line"> =&gt; [4/4] RUN pip install -r requirements.txt                                                                                                                                                                                                                                     63.6s</span><br><span class="line"> =&gt; exporting to image                                                                                                                                                                                                                                                             1.6s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                                                                                                                                                                                            0.9s</span><br><span class="line"> =&gt; =&gt; exporting manifest sha256:fb2f23e7feeb23365ee8cc3cd9a5a8c5d497c73538c16463e23195a6b873d7bf                                                                                                                                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting config sha256:41ffab42f6b9d9c336023838318f252e00e15a9d5a73cc17a765dae05fdc5435                                                                                                                                                                                    0.0s</span><br><span class="line"> =&gt; =&gt; exporting attestation manifest sha256:83d850f342fee281553b7b387484f4790d4553015fb12d4cec7ac00462229a25                                                                                                                                                                      0.0s</span><br><span class="line"> =&gt; =&gt; exporting manifest list sha256:1bfb1d56ae1e7a710f2f6277d9c2a6b2b746e6710a83b1792bea01ef7bbec520                                                                                                                                                                             0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/docker_test:latest                                                                                                                                                                                                                              0.0s</span><br><span class="line"> =&gt; =&gt; unpacking to docker.io/library/docker_test:latest    </span><br></pre></td></tr></table></figure>

<p><strong>创建容器并运行</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PS E:\docker\demo&gt; docker run -d -p 8000:8000 docker_test</span><br><span class="line">22fd617066ad0f95b1a664257f4c00a6dc1b60d9de7c894f8940f24b34859629</span><br><span class="line">PS E:\docker\demo&gt; docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                  CREATED         STATUS                     PORTS                                         NAMES</span><br><span class="line">22fd617066ad   docker_test   <span class="string">&quot;python3 main.py&quot;</span>        4 seconds ago   Up 4 seconds               0.0.0.0:8000-&gt;8000/tcp, [::]:8000-&gt;8000/tcp   sharp_banach</span><br><span class="line">PS E:\docker\demo&gt; curl http://127.0.0.1:8000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">StatusCode        : 200</span><br><span class="line">StatusDescription : OK</span><br><span class="line">Content           : &#123;<span class="string">&quot;hello&quot;</span>:<span class="string">&quot;dbkuaizi&quot;</span>&#125;</span><br><span class="line">RawContent        : HTTP/1.1 200 OK</span><br><span class="line">                    Content-Length: 20</span><br><span class="line">                    Content-Type: application/json</span><br><span class="line">                    Date: Tue, 09 Sep 2025 14:31:30 GMT</span><br><span class="line">                    Server: uvicorn</span><br><span class="line"></span><br><span class="line">                    &#123;<span class="string">&quot;hello&quot;</span>:<span class="string">&quot;dbkuaizi&quot;</span>&#125;</span><br><span class="line">Forms             : &#123;&#125;</span><br><span class="line">Headers           : &#123;[Content-Length, 20], [Content-Type, application/json], [Date, Tue, 09 Sep 2025 14:31:30 GMT], [Server, uvicorn]&#125;</span><br><span class="line">Images            : &#123;&#125;</span><br><span class="line">InputFields       : &#123;&#125;</span><br><span class="line">Links             : &#123;&#125;</span><br><span class="line">ParsedHtml        : System.__ComObject</span><br><span class="line">RawContentLength  : 20</span><br></pre></td></tr></table></figure>



<h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>Docker 网络 默认 Bridge（桥接模式），所有的容器都连接到这个网络中，每一个容器都分配了一个内部的 IP 地址，一般都是 172.17 开头。在这个内部子网里面，容器可以通过内部 IP 地址互相访问。</p>
<p>但<strong>容器网络和宿主机的网络是隔离的</strong>，可以使用 <code>docker network create</code> 命令创建子网，默认情况下，子网也是桥接模式的一种，然后可以指定容器加入不同的子网，同一个子网内的容器可以互相通信，而跨子网则不可以通信。</p>
<p>使用子网还有一个好处，同一个子网内的容器，可以直接使用容器名称互相访问，而不必使用内部的 IP 地址。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 名叫 network1 的子网</span></span><br><span class="line">docker network create network1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 nginx 容器 使用 network1 的子网</span></span><br><span class="line">docker run -d --network network1 nginx</span><br></pre></td></tr></table></figure>

<img src="/2025/09/20/docker/2.png" class="">

<h3 id="HOST-模式"><a href="#HOST-模式" class="headerlink" title="HOST 模式"></a>HOST 模式</h3><p>host 模式下，docker 容器直接共享宿主机的网络，容器直接使用宿主机的 IP 地址，无需 <code>-p</code> 参数进行端口映射，容器内的服务直接运行在宿主机的端口上，通过宿主机的 IP 和端口就能访问到容器中服务。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --network host nginx</span><br></pre></td></tr></table></figure>



<h3 id="NONE-模式"><a href="#NONE-模式" class="headerlink" title="NONE 模式"></a>NONE 模式</h3><p>这个模式表示不联网</p>
<h3 id="控制命令"><a href="#控制命令" class="headerlink" title="控制命令"></a>控制命令</h3><p><strong>创建网络</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create network1</span><br></pre></td></tr></table></figure>

<p><strong>查看网络</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; docker network list</span><br><span class="line">NETWORK ID     NAME       DRIVER    SCOPE</span><br><span class="line">d30095b3bc13   bridge     bridge    <span class="built_in">local</span></span><br><span class="line">24b646446630   host       host      <span class="built_in">local</span></span><br><span class="line">a26161c3eff2   network1   bridge    <span class="built_in">local</span></span><br><span class="line">7800c9b21eb6   none       null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<p>除了我们创建的模式以外，还有 Docker 自带的三种模式，需要注意的是 这三个自带的网络模式是不可删除的</p>
<p><strong>删除网络</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">rm</span> network1</span><br></pre></td></tr></table></figure>



<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>有的时候 一个完整的应用可能会是很多部分组成的，例如前端、后端、数据库 以及各种附加的技术栈，这些东西应该如何容器化呢？</p>
<p>我们可以自然的想到，将这些模块都打包在一起，做成一个巨大的容器。但这样做有一个弊端，只要其中一个模块发生故障，例如 服务端内存泄露，可能会导致整个容器都崩溃挂掉。</p>
<p>并且这样做的可伸缩性差，如果想给系统做扩容，只能把整个大容器在复制一份，做不到对某个模块的精确扩容。</p>
<p>多应用的最佳实践，是把每一个模块都打包成一个独立的容器。但这样多容器 增加了很多使用成本，因为想创建多个 容器 就要多次使用 docker run ，还需要配置容器之间的网络环境，尝试管理这些容器时，一个遗漏就会导致很多问题，并且若让其他人部署项目，如果操作者对部署流程不熟悉 也会导致各种问题的发生。</p>
<p>这个时候，容器编排技术就很有用了，也就是 <strong>Docker Compose</strong>，它使用 yml 文件 管理多个容器，在这个文件中记录了容器之间时如何创建以及如何协同工作的，我们可以简单的把 Docker Compose 文件理解成一个或多个 Docker run 命令，按照特定的格式书写到一个文件中，</p>
<p>Docker Compose 格式如下：</p>
<img src="/2025/09/20/docker/3.png" class="">

<ul>
<li>右侧最顶级的就是 Services 元素，每个元素就对应一个 Services</li>
<li>左侧的 <code>--name</code> 在右侧就变成了 services 名</li>
<li>左侧的镜像名，在右侧写在了 <code>image:</code> 属性后面</li>
<li>左侧的 <code>-e</code> 参数，对应右边的 <code>environments</code></li>
<li>左侧的 <code>-v</code> 对应右侧的 <code>volume</code> 也就是挂载卷。</li>
<li>左侧的 <code>-p</code> 对应右边的 <code>ports</code></li>
<li>右侧的 <code>depends_on</code> 用来表示启动顺序关系，这里表示 <code>my_mongodb_express</code> 容器，依赖 <code>my_mongodb</code> 。这时 程序会先启动 mongodb 再启动荣亲</li>
</ul>
<p>左右两边唯一的区别是：左边自定义了一个子网 <code>network1</code> ，而右边没有。同一个 <code>compose</code> 文件中，定义的所有容器都会自动加入同一个子网，不用我们额外维护。</p>
<p>我们可以借助 AI 来生成 需要的 Compose 文件，而无需手动编写。</p>
<p><strong>使用 Compose</strong></p>
<p>在启动目录下创建 <code>docker-compose.yaml</code> 文件，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my_mongodb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MONGO_INITDB_ROOT_USERNAME:</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">MONGO_INITDB_ROOT_PASSWORD:</span> <span class="string">pass</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/my/datadir:/data/db</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">my_mongodb_express:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo-express</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:8081</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ME_CONFIG_MONGODB_SERVER:</span> <span class="string">my_mongodb</span></span><br><span class="line">      <span class="attr">ME_CONFIG_MONGODB_ADMINUSERNAME:</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">ME_CONFIG_MONGODB_ADMINPASSWORD:</span> <span class="string">pass</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my_mongodb</span></span><br></pre></td></tr></table></figure>

<p><strong>创建并运行启动</strong></p>
<p>然后执行 <code>docker compose up -d</code> 运行，如果容器已经在运行了 重复执行这个命令不会有任何效果。</p>
<p>执行该命令时，会检测当前目录下 名为 <code>docker-compose.yaml</code> 或 <code>compose.yaml</code> 文件。可以通过 <code>docker compose -f tesst.yaml up -d</code> 指定 compose 文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS E:\dbkuaizi\mongodb&gt; docker compose up -d</span><br><span class="line">[+] Running 3/3</span><br><span class="line"> ✔ Network mongodb_default                 Created                                                                 0.0s</span><br><span class="line"> ✔ Container mongodb-my_mongodb-1          Started                                                                 0.6s</span><br><span class="line"> ✔ Container mongodb-my_mongodb_express-1  Started                                                                 0.7s</span><br><span class="line">PS E:\dbkuaizi\mongodb&gt;</span><br></pre></td></tr></table></figure>

<p><strong>停止并删除</strong></p>
<p><code>docker compose down</code> 命令会停止并删除容器</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS E:\docker\mongodb&gt; docker compose down</span><br><span class="line"><span class="keyword">time</span>=<span class="string">&quot;2025-09-18T21:47:55+08:00&quot;</span> level=warning msg=<span class="string">&quot;E:\\docker\\mongodb\\docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion&quot;</span></span><br><span class="line">[+] Running 3/3</span><br><span class="line"> ✔ Container mongodb-my_mongodb_express-1  Removed                                                                 0.3s</span><br><span class="line"> ✔ Container mongodb-my_mongodb-1          Removed                                                                 0.3s</span><br><span class="line"> ✔ Network mongodb_default                 Removed                                                                 0.4s</span><br></pre></td></tr></table></figure>

<p><strong>停止不删除</strong></p>
<p><code>docker compose stop</code> 命令会停止并且不会删除容器</p>
<p><strong>启动</strong></p>
<p><code>docker compose start</code> 命令会启动停止的容器</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">王桑</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/09/20/docker/">http://example.com/2025/09/20/docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">王桑的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/docker%E7%AC%94%E8%AE%B0/">-docker笔记</a></div><div class="post-share"><div class="social-share" data-image="/img/docker.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/08/03/Redis/" title="Redis"><img class="cover" src="/img/redis.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Redis</div></div><div class="info-2"><div class="info-item-1">Redis的5种常用数据类型一、字符串类型命令设置指定的key值 1set key value  获取指定key值 1get key  设置指定的key值，并将key 的过期时间设为seconds秒 1setex key seconds value  只有在key不存在时设置key的值 1setnx key value    二、哈希操作命令将哈希表中的字段field的值设为value 1hsert key field value  获取存储在哈希表中指定字段的值 1hget key field   删除存储在哈希表中的指定字段 1hdel key field  获取哈希表中的所有字段 1heys key  获取哈希表中所有值 1hvals key    三、列表操作指令（先进先出，后进的排上面，同队列操作）将一个或多个值插入到列表头部 1lpush key value1 value2 .......  获取列表指定范围内的元素(不知道stop 时填-1，会查询到最后) 1lrange key start stop   移除并获取列表最后一个元素 1rpop...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/wang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">王桑</div><div class="author-info-description">轻舟已撞大冰山</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wangsanghh"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">Docker 核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">Docker 技术原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%AE%89%E8%A3%85"><span class="toc-number">3.</span> <span class="toc-text">Docker 安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F"><span class="toc-number">4.</span> <span class="toc-text">Docker 镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="toc-number">4.1.</span> <span class="toc-text">下载镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F"><span class="toc-number">4.2.</span> <span class="toc-text">查看镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-number">4.3.</span> <span class="toc-text">删除镜像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%AE%B9%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">Docker 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">创建并运行容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">创建容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%88%97%E8%A1%A8"><span class="toc-number">5.3.</span> <span class="toc-text">容器列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%81%9C%E5%AE%B9%E5%99%A8"><span class="toc-number">5.4.</span> <span class="toc-text">启停容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-number">5.5.</span> <span class="toc-text">删除容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8"><span class="toc-number">5.6.</span> <span class="toc-text">容器内部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">5.7.</span> <span class="toc-text">查看创建信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97"><span class="toc-number">5.8.</span> <span class="toc-text">容器日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%8D%B7"><span class="toc-number">6.</span> <span class="toc-text">Docker 卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8D%B7"><span class="toc-number">6.1.</span> <span class="toc-text">创建卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%8D%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">6.2.</span> <span class="toc-text">查看卷信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E5%8D%B7"><span class="toc-number">6.3.</span> <span class="toc-text">查看所有卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%8D%B7"><span class="toc-number">6.4.</span> <span class="toc-text">删除卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8D%B7"><span class="toc-number">6.5.</span> <span class="toc-text">删除未使用的卷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile"><span class="toc-number">7.</span> <span class="toc-text">Dockerfile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E7%BD%91%E7%BB%9C"><span class="toc-number">8.</span> <span class="toc-text">Docker 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HOST-%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">HOST 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NONE-%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.3.</span> <span class="toc-text">NONE 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4"><span class="toc-number">8.4.</span> <span class="toc-text">控制命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-Compose"><span class="toc-number">9.</span> <span class="toc-text">Docker Compose</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/20/docker/" title="docker"><img src="/img/docker.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker"/></a><div class="content"><a class="title" href="/2025/09/20/docker/" title="docker">docker</a><time datetime="2025-09-20T12:18:50.000Z" title="发表于 2025-09-20 20:18:50">2025-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/03/Redis/" title="Redis"><img src="/img/redis.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis"/></a><div class="content"><a class="title" href="/2025/08/03/Redis/" title="Redis">Redis</a><time datetime="2025-08-03T06:56:51.000Z" title="发表于 2025-08-03 14:56:51">2025-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/09/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Git常用命令"><img src="/img/git.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git常用命令"/></a><div class="content"><a class="title" href="/2025/07/09/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="Git常用命令">Git常用命令</a><time datetime="2025-07-09T08:42:12.000Z" title="发表于 2025-07-09 16:42:12">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/22/%E8%87%AA%E5%BB%BA%E9%A2%98%E5%BA%93/" title="自建题库"><img src="/img/zerror(2).png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自建题库"/></a><div class="content"><a class="title" href="/2025/06/22/%E8%87%AA%E5%BB%BA%E9%A2%98%E5%BA%93/" title="自建题库">自建题库</a><time datetime="2025-06-22T14:56:14.000Z" title="发表于 2025-06-22 22:56:14">2025-06-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/21/hello-world/" title="Hello World">Hello World</a><time datetime="2025-06-21T14:53:24.261Z" title="发表于 2025-06-21 22:53:24">2025-06-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/docker1.png);"><div id="footer-wrap"><div class="copyright">&copy;2025 By 王桑</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'xZNj8pFU0a94j5YlCOobLQU5-gzGzoHsz',
      appKey: 'pfK28aeGS6NhdPsfbZ0qWt07',
      avatar: 'monsterid',
      serverURLs: 'https://xznj8pfu.lc-cn-n1-shared.com',
      emojiMaps: "",
      visitor: true,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>